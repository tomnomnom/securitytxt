package securitytxt

import (
	"io"
	"strings"
)

// A File represents a security.txt file
type File struct {
	errors   []error
	comments []string

	fields []Field
}

func (f *File) addField(nf Field) {
	f.fields = append(f.fields, nf)
}

func (f File) Fields(filter string) []Field {
	if filter == "" {
		return f.fields
	}

	out := make([]Field, 0)
	for _, field := range f.fields {
		if strings.ToLower(field.option) == filter {
			out = append(out, field)
		}
	}
	return out
}

// FromReader returns a new *File, generated by parsing
// the contents of the provided io.Reader, and an error
// if any errors were encountered. More detail can be
// obtained by calling the returned *File's Errors() method
func FromReader(r io.Reader) (*File, error) {
	return parse(r)
}

// HasAcknowledgments returns true if there is at least one acknowledgments value
func (f File) HasAcknowledgments() bool {
	return len(f.Acknowledgments()) > 0
}

// Acknowledgments returns a slice of acknowledgments values from the File
func (f File) Acknowledgments() []Field {
	return f.Fields(acknowledgmentsField)
}

// Contact returns a slice of contact values from the File
func (f File) Contact() []Field {
	return f.Fields(contactField)
}

// PhoneContact returns any contact values that are valid phone numbers
func (f File) PhoneContact() []Field {
	out := make([]Field, 0)
	for _, c := range f.Contact() {
		if validPhone(c.String()) {
			out = append(out, c)
		}
	}

	return out
}

// URIContact returns any contact values that are valid URIs
func (f File) URIContact() []Field {
	out := make([]Field, 0)
	for _, c := range f.Contact() {
		if validURI(c.String()) {
			out = append(out, c)
		}
	}

	return out
}

// EmailContact returns any contact values that are valid email addresses
func (f File) EmailContact() []Field {
	out := make([]Field, 0)
	for _, c := range f.Contact() {
		if validEmail(c.String()) {
			out = append(out, c)
		}
	}

	return out
}

// HasCanonical returns true if there is at least one canonical value
func (f File) HasCanonical() bool {
	return len(f.Canonical()) > 0
}

// Canonical returns a slice of canonical values from the File
func (f File) Canonical() []Field {
	return f.Fields(canonicalField)
}

// HasEncryption returns true if there is at least one encryption value
func (f File) HasEncryption() bool {
	return len(f.Encryption()) > 0
}

// Encryption returns a slice of encryption URIs from the File
func (f File) Encryption() []Field {
	return f.Fields(encryptionField)
}

// HasHiring returns true if there is at least one hiring value
func (f File) HasHiring() bool {
	return len(f.Hiring()) > 0
}

// Hiring returns a slice of hiring values from the File
func (f File) Hiring() []Field {
	return f.Fields(hiringField)
}

// HasPolicy returns true if there is at least one policy value
func (f File) HasPolicy() bool {
	return len(f.Policy()) > 0
}

// Policy returns a slice of policy values from the File
func (f File) Policy() []Field {
	return f.Fields(policyField)
}

// HasPreferredLanguages returns true if there is at least one preferredLanguages value
func (f File) HasPreferredLanguages() bool {
	return len(f.PreferredLanguages()) > 0
}

// PreferredLanguages returns a slice of preferredLanguages values from the File
func (f File) PreferredLanguages() []Field {
	return f.Fields(preferredLanguagesField)
}

// addComment adds a comment to the File
func (f *File) addComment(c string) {
	f.comments = append(f.comments, c)
}

// Comments returns a slice of comments from the File
func (f File) Comments() []string {
	return f.comments
}

// addError adds an error value to the File
func (f *File) addError(err error) {
	f.errors = append(f.errors, err)
}

// HasErrors returns true if any errors occured during parsing
func (f File) HasErrors() bool {
	return len(f.errors) > 0
}

// Errors returns a slice of errors encountered during parsing
func (f File) Errors() []error {
	return f.errors
}
